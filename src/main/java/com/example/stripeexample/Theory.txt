A PaymentIntent. Stripe uses this to represent your intent to collect payment from a customer, tracking your charge attempts and payment state changes throughout the process.

A Customer (optional). To set up a payment method for future payments, it must be attached to a Customer.
Create a Customer object when your customer creates an account with your business.
If your customer is making a payment as a guest, you can create a Customer object before payment and associate
it with your own internal representation of the customer’s account later.


For security reasons, your app can’t create these objects. Instead, add an endpoint on your server that:

Retrieves the Customer, or creates a new one.
Creates an Ephemeral Key for the Customer.
Creates a PaymentIntent, with the amount, currency, customer, and automatic_payment_methods enabled.
Returns the Payment Intent’s client secret, the Ephemeral Key’s secret, the Customer’s id, and your publishable key to your app.




We recommend creating a PaymentIntent as soon as you know the amount, such as when the customer begins the checkout process,
to help track your sales funnel. If the amount changes, you can update its amount.
 For example,if your customer backs out of the checkout process and adds new items to their cart,
  you may need to update the amount when they start the checkout process again.

If the checkout process is interrupted and resumes later, attempt to reuse the same PaymentIntent instead of creating a new one.
 Each PaymentIntent has a unique ID that you can use to retrieve it if you need it again. In the data model of your application,
  you can store the ID of the PaymentIntent on the customer’s shopping cart or session to facilitate retrieval.
   The benefit of reusing the PaymentIntent is that the object helps track any failed payment attempts for a given cart or session.

You should also provide an idempotency key when creating the PaymentIntent to avoid erroneously creating duplicate PaymentIntents
 for the same purchase. This key is typically based on the ID that you associate with the cart or customer session in your application.


Idempotent Requests

//build request(create intent,create refund ...)
Stripe.apiKey = "sk_test_51M0N5GFtmfxzG6wMv5rF80PkxBXT7WTOC9fudwDsAdWwws4buKuvv7XlyNTrtIFlV7RkVOesXFLQ2hUUnmticZCd0016lhtl2c";

Map<String, Object> chargeParams = new HashMap<>();
chargeParams.put("amount", 2000);
chargeParams.put("currency", "usd");
chargeParams.put("description", "My First Test Charge (created for API docs at https://www.stripe.com/docs/api)");
chargeParams.put("source", "tok_visa");


//set options when executing code
RequestOptions options = RequestOptions
  .builder()
  .setIdempotencyKey("LaX9HUoiaB69hdv6")
  .build();

charge.create(chargeParams, options);


The API supports idempotency for safely retrying requests without accidentally performing the same operation twice.
When creating or updating an object, use an idempotency key.
Then, if a connection error occurs, you can safely repeat the request
without risk of creating a second object or performing the update twice.
To perform an idempotent request, provide a key to setIdempotencyKey() on a request.

Stripe's idempotency works by saving the resulting status code and body of the first request made for any given idempotency key,
regardless of whether it succeeded or failed. Subsequent requests with the same key return the same result, including 500 errors.

An idempotency key is a unique value generated by the client which the server uses to recognize subsequent retries of the same request.
How you create unique keys is up to you, but we suggest using V4 UUIDs, or another random string with enough entropy
to avoid collisions. Idempotency keys can be up to 255 characters long.

Keys are eligible to be removed from the system automatically after they're at least 24 hours old,
 and a new request is generated if a key is reused after the original has been pruned.
 The idempotency layer compares incoming parameters to those of the original request and errors unless
 they're the same to prevent accidental misuse.

Results are only saved if an API endpoint started executing.
If incoming parameters failed validation, or the request conflicted with another that was executing concurrently,
 no idempotent result is saved because no API endpoint began execution. It is safe to retry these requests.


All POST requests accept idempotency keys.
Sending idempotency keys in GET and DELETE requests has no effect and should be avoided,
 as these requests are idempotent by definition.

 The PaymentIntent contains a client secret, a key that’s unique to the individual PaymentIntent.
  On the client side of your application, Stripe.js uses the client secret as a parameter when invoking functions
   (such as stripe.confirmCardPayment or stripe.handleCardAction) to complete the payment.

 To use the client secret, you must obtain it from the PaymentIntent on your server and pass it to the client side.
  You can use different approaches to get the client secret to the client side.
   Choose the approach that best suits the architecture of your application.

The Setup Intents API lets you save a customer’s card without an initial payment.
This is helpful if you want to onboard customers now, set them up for payments, and charge them in the future—when they’re offline.



A SetupIntent is an object that represents your intent to set up a customer’s payment method for future payments.

A Customer. To set up a payment method for future payments, it must be attached to a Customer.
 Create a Customer object when your customer creates an account with your business.
 If your customer is making a payment as a guest, you can create a Customer object before payment and associate
  it with your own internal representation of the customer’s account later.

A Customer Ephemeral Key (optional). Information on the Customer object is sensitive, and can’t be retrieved directly from an app.
 An Ephemeral Key grants the SDK temporary access to the Customer.

For security reasons, your app can’t create these objects. Instead, add an endpoint on your server that:

Retrieves the Customer, or creates a new one.
Creates an Ephemeral Key for the Customer.
Creates a SetupIntent with the Customer ID.
Returns the SetupIntent’s client secret, the Ephemeral Key’s secret, the Customer’s ID, and your




Standard account:
A Stripe account controlled directly by the account holder (that is, your platform’s user).
A user with a Standard account has a relationship with Stripe, is able to log into the Stripe Dashboard, can process charges on their own,
 and can disconnect their account from your platform.

Express account:
An account where Stripe handles user onboarding, account management, and identity verification.
 Your platform can manage payout schedules, customize the flow of funds, and control branding.

Custom account: This account is almost completely invisible to the account holder and Stripe has no direct contact with them.
 Custom accounts require the most integration effort and are suitable for platforms who want to control the entire user experience.

 Capabilities define what your connected account can do and track whether they’ve met the verification requirements to do so.
  Connected accounts with the transfers capability can accept transfers of funds from your platform,
   while connected accounts with the card_payments capability can directly process payments without routing the funds through your platform.
   To know which capabilities Stripe recommends for your business model, refer to your completed platform profile.

If you’re onboarding Express accounts, Stripe collects all the user requirements information for you (excluding any fields you choose to pre-fill).
For instructions on how to onboard Express accounts, refer to Using Connect with Express accounts.








































